---
title: 多态
date: 2017-12-10 08:40:43
update: 2017-12-10 15:00:00
comments: true
categories: C++
tags: C++
---

# 多态的条件

- 必须存在继承关系
- 继承关系必须有同名虚函数
- 存在基类类型的指针或者引用，通过该指针或引用调用虚函数。

# 虚函数声明
- 纯虚函数声明如下： `virtual void funtion()=0` 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，__抽象类不能定义实例__，但可以声明指向实现该抽象类的具体类的指针或引用。
- 虚函数声明如下：`virtual ReturnType FunctionName(Parameter)` 虚函数必须实现。

不建议用父类指针指向子类，尤其是父类析构函数没有声明为虚函数，采用父类指针，其生存周期结束时会自动调用父类的析构函数，而不会调用子类析构函数，子类未完全析构，造成内存泄漏。

**实现多态父类析构函数定义为虚函数**
1. 构造函数顺序：先执行父类的构造函数，再执行子类的构造函数
2. 析构函数顺序：先执行子类的析构函数，再执行父类的析构函数

3. 父类析构函数没有定义为virtual时
```C++
class mParent
{
public:
	mParent()
	{
		cout << "p gouzhao" << endl;
	}
	 ~mParent()
	{
		cout << "p xigou" << endl;
	}
	virtual void print()
	{
		cout << "this is parent" << endl;
	}
};
```
子类A
```C++
class A : public mParent
{
public:
	A()
	{
		cout << "A gouxhao" << endl;
	}

	~A()
	{
		cout << "A xigou" << endl;
	}

	virtual void print()
	{
		cout << "this is A" << endl;
	}
};

```

使用多态
```C++
parent * p = new A;
p->F();
delete p;
```
结果是：
![jieguo](/多态/结果.png)
此时`delete p` __没有使用子类A的析构函数__，如果A里有裸指针，则会造成内存泄漏

4. 父类析构函数定义为virtual时
```C++
class mParent
{
public:
	mParent()
	{
		cout << "p gouzhao" << endl;
	}
	 virtual ~mParent()
	{
		cout << "p xigou" << endl;
	}
	virtual void print()
	{
		cout << "this is parent" << endl;
	}
};
```
结果是：
![jieguo](/多态/结果1.png)
此时`delete p` __使用子类A的析构函数__.



# 静态多态
    在编译时实现多态


# 动态多态
    在运行时实现多态
